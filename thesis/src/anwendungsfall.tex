\chapter{Anwendungsfall: Jitter-Analyse von Software-generierten MIDI-Clock Signalen}
\label{ch:Anwendungsfall}
Als Beispiel für ein zeitkritisches Signal sollen im Folgenden mehrere MIDI-Clock Signale mit dem Event-Recorder untersucht werden, und dabei der allgemeine Ablauf einer Event-Aufnahme und der nachfolgenden Analyse geschildert werden.
Das MIDI-Clock Signal wird in den untersuchten Fällen software-basiert -- auf einem normalen Anwender-System -- generiert, deswegen ist von einer messbaren zeitlichen Fluktuation (``Jitter'') auszugehen, das heißt die Clock-Signale treten nicht exakt zum erwarteten Zeitpunkt sondern leicht zeitlich verfrüht oder verspätetet auf.\\
\acrshort{MIDI} ist ein 1983 spezifizierter Standard für den Austausch von Steuerinformation zwischen elektronischen Musikintrumenten und wird trotz einiger signifikanter Limitierungen seit über 35 Jahren nahezu unverändert für praktisch alle elektronischen Musikinstrumente im professionellen und Hobby-Bereich verwendet. 
%Die wohl bedeutenste Limitierung ist die Verwendung von 7-bit-Werten für Parameter wie zum Beispiel den Notenwert, Anschlagstärke oder von Control-Change-Werten (also eine Beschränkung auf den Wertebereich von 0 -127).\\
MIDI bietet mit der ``MIDI-Clock'' eine Möglichkeit mehrere Geräte zeitlich zu synchronisieren. So könnte zum Beispiel ein Synthesizer mit der Musiksoftware auf einem PC synchronisiert werden, um tempo-abhängige Arpeggios\footnote{Ein Akkord bei dem die einzelnen Töne nicht gleichzeitig, sondern versetzt nacheinander gespielt oder ausgelöst werden} zu spielen.\\
Dabei verwendet MIDI zur Datenübertragung das gleiche Protokoll wie ein \acrshort{UART} (ohne Parity-Bit) bei einer Übertragungsgeschwindigkeit 31250 Bit/s. Die meisten MIDI-Nachrichten setzen sich aus einem Stautsbyte und zwei darauf folgenden Datenbytes zusammten, für die MIDI-Clock werden allerdings nur einzelne Bytes benötigt. \\
Zuerst wird ein Start-Byte (0xFA) übertragen, dann wird -- abhängig vom Tempo -- 24 mal pro Viertelnote ein ``Clock-Tick'' (0xF8) gesendet, und abschließend ein Stopp-Bit (0xFC). \\     
Eine Implementierung in Python könnte folgendermaßen aussehen:
\begin{lstlisting}[language=python]
# MIDI CLOCK TEMPO (beats per minute)
BPM = 80

# define clock messages
clock_start = [0xFA]
clock_tick  = [0xF8]
clock_stop  = [0xFC]
[...]
    # calculate clock period
    clock_period = 60 / (BPM * 24)

    # send start byte 
    midiout.send_message(clock_start)

    # run
    while (True):
        midiout.send_message(clock_tick)
        time.sleep(clock_period)

\end{lstlisting}

\section{Test-Setup: USB-Midi mit Teensy LC}
  
Um das MIDI-Signal auswerten zu können wird ein Mikrokontroller (``Teensy LC'') verwendet, der per USB an einen PC angeschlossen werden kann, und über die USB-Schnittstelle ein MIDI-Gerät simuliert.  Das heißt am PC wird eine MIDI-Schnittstelle erzeugt, und die MIDI-Daten werden direkt zum Mikrocontroller übertragen. Der Mikrocontroller wartet auf das Start-Byte und setzt einen GPIO-Pin auf ``1'' um dem Event-Recorder den Anfang der Aufnahme zu signalisieren. 
Danach wird bei jedem empfangenen Clock-Tick der ein zweiter GPIO-Pin kurz auf ``1'' gesetzt und anschließend wieder auf ``0''. Dies soll beim Event-Recorder als Event erkannt werden. Beim Empfangen des Stopp-Bytes word der erste GPIO-Pin auf ``0'' gesetzt und die Aufnahme soll beendet werden.\\
Der Mikrocontroller kann mit der Arduino-IDE programmiert werden und es steht eine MIDI-Bibliothek zur Verfügung, was eine kurze und unkomplizierte Umsetzung erlaubt:
\begin{lstlisting}[language=c]
[...]
// midi clock start handler (0xFA)
void onStart() {
  digitalWrite(0, HIGH);
}

// midi clock tick handler (0xF8) 
void onClock() {
    digitalWrite(1, HIGH);
    digitalWrite(1, LOW);
}

// midi clock stop handler (0xFC)
void onStop() {
  digitalWrite(0, LOW);
}

void setup() {
  // pin setup
  [...]
  // register midi handlers
  usbMIDI.setHandleStart(onStart);
  usbMIDI.setHandleStop(onStop);
  usbMIDI.setHandleClock(onClock);
}

void loop() {
  usbMIDI.read();
}
\end{lstlisting}

\section{Einrichten des Projekts}
\label{ch:Anwendungsfall:sec:Einrichten}

Die vollständige Einrichtung des Raspberry Pi Zero W soll hier aus Platzgründen nicht beschrieben werden, es steht aber eine detailliertere Anleitung im Projekt-Wiki zur Verfügung.
Der grundsätzliche Ablauf ist wiefolgt:
\begin{enumerate}

\item Download, Kompilieren und Installation der IceStorm-Toolchain auf den Anwender-PC (Linux-System)

\begin{lstlisting}[language=bash]
# siehe http://www.clifford.at/icestorm/#install
\end{lstlisting}

\item Download, Kompilieren und Installation der RISC-V Toolchain

\begin{lstlisting}[language=bash]
git clone git@github.com:cliffordwolf/picorv32.git
cd picorv32
make download-tools
make -j\$(nproc) build-tools
\end{lstlisting}

Das Kompilieren der RISC-V gcc-Toolchain kann je nach Rechenleistung mehrere Stunden dauern.

\item Download des Git-Projekts auf den Anwender-PC (Linux-System)

\begin{lstlisting}[language=bash]
cd ..
git clone https://github.com/dm7h/icozsoc.git
\end{lstlisting}


\item Einrichten der SSH-Verbindung zum Raspberry Pi Zero W 

\begin{lstlisting}[language=bash]
# siehe zum Beispiel: https://www.raspberrypi.org/documentation/remote-access/ssh/passwordless.md
# Exportieren des SSH-Hostsi, z.B.:
export SSH_RASPI=pi@zero
# eine SSH-Verbindung sollte dann ohne Passwort-Abfrage m\"oglich sein:
ssh \textdollar SSH_RASPI
\end{lstlisting}

\item Download, Kompilieren und Installation des icozctl Git-Projekts 
Zur Installation des icozctl-Tools wird auf dem Raspberry Pi folgendes ausgeführt:
\begin{lstlisting}[language=bash]
git clone https://github.com/dm7h/icozctl
cd icozctl
sudo make install
\end{lstlisting}

\item Generieren und Programmieren des Bitfiles mithilfe des zur Verfügung gestellten Makefiles
Wenn icozctl erfolgreich installiert wurde, kann auf dem Anwender-PC das FPGA-Bitstream und die 
IcoSoc-Anwendung kompiliert und via Raspberry Pi auf die Hardware geflasht werden:
\begin{lstlisting}[language=bash]
cd ../icozsoc/examples/event-recorder/
make prog_flash
\end{lstlisting}

 
\end{enumerate}

\section{Konfiguration der Event-Trigger}
\label{ch:Anwendungsfall:sec:Event-Trigger}

Um die Events zu konfigurieren wird zunächst auf das Raspberry Pi gewechselt.  
Im Ordner des icozctl-Tools befindet sich die Event-Konfigurations-Datei ``config.yml''.
Für die Aufnahme wird nicht zwangsläufig eine Event-Erkennung benötig, es kann aber aber trotzdem ein Start-, Stopp- und Clock-Event definiert werden um unnötige Aufnahmedaten zu minimieren:

\begin{lstlisting}[language=yaml]
# event configuration
events: 
  - start:
          trigger: u
          funcion: start

  - stop:
          trigger: d
          function: stop

  - clk_up:
          trigger: 1u

  - clk_down:
          trigger: 1d

\end{lstlisting}


\clearpage


\section{Durchführen der Event-Aufnahme}
\label{ch:Anwendungsfall:sec:Durchführung}

Die Auswertung soll für Anschauungszwecke das VCD-Dateiformat verwenden.
Die Aufnahme kann dann mit folgendem Befehl gestartet werden:
\begin{lstlisting}[language=bash]
icozctl -c config.yml -o midi_clock.vcd
\end{lstlisting}

Das Programm wartet nun auf Eingangsdaten, die zum Beispiel durch das Starten der in Python implementieren Midi-Clock oder durch ein Musikprogramm geliefert werden können.
Die Aufnahme kann zu jedem Zeitpunkt durch die Tastenkombination Strg+c beendet werden.
Das Ergebnis der Aufnahme kann zum Beispiel mit gtkwave grafisch dargestellt und überprüft werden:
[screenshot]

\section{Analyse der Ergebnisse}
\label{ch:Anwendungsfall:sec:Analyse}

Für die Analyse der Daten kann zum Beispiel ein Python-Skript verwendet werden. Um Aussagen über den Jitter des Signals machen zu können bietet sich die Generierung eines Histogramms an, bei dem auf der x-Achse die Abweichung zum erwarteten Clock-Signal und auf der y-Achse die Häufigkeit der Abweichung dargestellt wird.

Für das Einlesen der VCD-Datei wird das Pythong-Modul Verilog\_VCD verwendet:
\begin{lstlisting}[language=python]
import Verilog_VCD
vcd = Verilog_VCD.parse_vcd('midi_clock.vcd')
\end{lstlisting}

Im VCD-Dateiformat wird jedem Signal ein Symbol als Abkürzung zugewiesen, auf die Daten des ersten Signals der Datei kann zum Beispiel mit der Abkürzung ``!'' zugegriffen werden.
Die Zeitstempel sind in der Python-Liste unter dem Index "tv" (``time value'') abrufbar. 
Der zeitliche Abstand zum jeweils vorhergehenden Event (Zeit-Delta) kann folgendermaßen berechnet werden:
 
\begin{lstlisting}[language=python]
# get the first time value
last = vcd["!"]["tv"][0][0]

# calculate time deltas
deltas = []
for item in vcd["!"]["tv"][1:]: 
    deltas.append(item[0]-last)
    last = item[0]
\end{lstlisting}

Die Daten werden in ein numpy-Array umgwandelt und es wird die Differenz zum erwarteten Zeit-Delta gebildet. 
Anschließend werden sie in eine pandas-Zeitserie konvertiert, wodurch automatisch statistisch relevante Kennwerte wie der Mittelwert und die Standardabweichung berechnet und angezeigt werden können:
 
\begin{lstlisting}[language=python]
np_deltas = np.array(deltas)
expected_delta = 31250000 # expected clock period in nanoseconds
np_deltas -= expected_delta
print(deltas_series.describe())
\end{lstlisting}

Abschließend wird mithilfe der matplotlib-Bibliothek ein Histogramm in Millisekunden-Auflösung erzeugt und angezeigt:

\begin{lstlisting}[language=python]
(deltas_series/pd.Timedelta(milliseconds = 1)).hist()
[...]
plt.show()
\end{lstlisting}

\subsection{Software MIDI-Clock: Python-Implementierung}

\subsection{Software MIDI-Clock: Renoise}

\subsection{Hardware MIDI-Clock: Midipal}

[buildern]

