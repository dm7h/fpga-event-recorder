-- This file was generated by				
-- Qfsm Version 0.53					
-- (C) Stefan Duffner, Rainer Strobel			


-- Inputs:   start_i
-- State/Output out1 out2 out3 out4 out5 trigger
-- idle         0    1    1    0    1    0       
-- Zustand_1    0    1    1    0    1    1       
-- Zustand_2    0    1    1    0    1    1       
-- Zustand_3    1    1    1    0    1    1       
-- Zustand_4    1    0    0    1    0    1       
-- Zustand_5    1    1    1    0    1    1       
-- Zustand_6    0    1    1    0    1    1       
-- Zustand_7    1    0    0    1    0    1       
-- Zustand_8    1    1    0    0    1    1       
-- Zustand_9    1    0    0    0    1    1       
-- Zustand_10   0    1    1    0    1    1       
-- Zustand_11   1    0    0    1    0    1       
-- Zustand_12   0    1    1    0    0    1       
-- Zustand_13   0    1    1    0    0    1       
-- Zustand_14   0    1    1    0    1    1       
-- Zustand_15   1    0    0    1    0    1       
-- Zustand_16   1    1    0    0    0    1       
-- Zustand_17   1    1    1    0    0    1       
-- Zustand_18   0    1    1    0    1    1       
-- Zustand_19   0    1    1    0    1    1       
-- Zustand_20   0    1    1    0    1    0       

LIBRARY IEEE;

USE IEEE.std_logic_1164.ALL;

ENTITY tple_wave IS
  PORT (clk: IN std_ulogic;
        rst_p: IN std_ulogic;
        start_i: IN std_ulogic;
        out1: OUT std_ulogic;
        out2: OUT std_ulogic;
        out3: OUT std_ulogic;
        out4: OUT std_ulogic;
        out5: OUT std_ulogic;
        trigger: OUT std_ulogic);
END tple_wave;

ARCHITECTURE behave OF tple_wave IS

TYPE state_type IS (idle, Zustand_1, Zustand_2, Zustand_3, Zustand_4, Zustand_5, Zustand_6, Zustand_7, Zustand_8, Zustand_9, Zustand_10, Zustand_11, Zustand_12, Zustand_13, Zustand_14, Zustand_15, Zustand_16, Zustand_17, Zustand_18, Zustand_19, Zustand_20);
SIGNAL next_state, current_state : state_type;

BEGIN
  state_register: PROCESS (rst_p, clk)
  BEGIN
    IF rst_p='1' THEN
      current_state <= idle;
    ELSIF rising_edge(clk) THEN
      current_state <= next_state;
    END IF;
  END PROCESS;

  next_state_and_output_logic: PROCESS (current_state, start_i)
    VARIABLE temp_input : std_ulogic_vector(0 DOWNTO 0);
    VARIABLE temp_output : std_ulogic_vector(5 DOWNTO 0);
  BEGIN
    temp_input(0) := start_i;
    CASE current_state IS
      WHEN idle => temp_output := "011010";
        IF temp_input="1" THEN
          next_state <= Zustand_1;
        ELSIF temp_input="0" THEN
          next_state <= idle;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Zustand_1 => temp_output := "011011";
          next_state <= Zustand_2;
      WHEN Zustand_2 => temp_output := "011011";
          next_state <= Zustand_3;
      WHEN Zustand_3 => temp_output := "111011";
          next_state <= Zustand_4;
      WHEN Zustand_4 => temp_output := "100101";
          next_state <= Zustand_5;
      WHEN Zustand_5 => temp_output := "111011";
          next_state <= Zustand_6;
      WHEN Zustand_6 => temp_output := "011011";
          next_state <= Zustand_7;
      WHEN Zustand_7 => temp_output := "100101";
          next_state <= Zustand_8;
      WHEN Zustand_8 => temp_output := "110011";
          next_state <= Zustand_9;
      WHEN Zustand_9 => temp_output := "100011";
          next_state <= Zustand_10;
      WHEN Zustand_10 => temp_output := "011011";
          next_state <= Zustand_11;
      WHEN Zustand_11 => temp_output := "100101";
          next_state <= Zustand_12;
      WHEN Zustand_12 => temp_output := "011001";
          next_state <= Zustand_13;
      WHEN Zustand_13 => temp_output := "011001";
          next_state <= Zustand_14;
      WHEN Zustand_14 => temp_output := "011011";
          next_state <= Zustand_15;
      WHEN Zustand_15 => temp_output := "100101";
          next_state <= Zustand_16;
      WHEN Zustand_16 => temp_output := "110001";
          next_state <= Zustand_17;
      WHEN Zustand_17 => temp_output := "111001";
          next_state <= Zustand_18;
      WHEN Zustand_18 => temp_output := "011011";
          next_state <= Zustand_19;
      WHEN Zustand_19 => temp_output := "011011";
          next_state <= Zustand_20;
      WHEN Zustand_20 => temp_output := "011010";
          next_state <= idle;
      WHEN OTHERS => temp_output := (OTHERS =>'X');
      next_state <= idle;
    END CASE;
    out1 <= temp_output(5);
    out2 <= temp_output(4);
    out3 <= temp_output(3);
    out4 <= temp_output(2);
    out5 <= temp_output(1);
    trigger <= temp_output(0);
  END PROCESS;

END behave;
